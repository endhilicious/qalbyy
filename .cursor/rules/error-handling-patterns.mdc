# Error Handling Patterns

## üéØ CRITICAL: Always Handle Errors Gracefully

**NEVER** let errors crash the application or leave users with broken UI. Always implement proper error boundaries and user-friendly error messages.

### Error Boundary Implementation

```tsx
// ‚úÖ CORRECT - Error boundary component
import React, { Component, ErrorInfo, ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo)
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="p-6 text-center">
          <h2 className="text-xl font-semibold text-red-600 mb-2">
            Something went wrong
          </h2>
          <p className="text-gray-600 mb-4">
            We're sorry, but something unexpected happened.
          </p>
          <button
            onClick={() => this.setState({ hasError: false })}
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Try again
          </button>
        </div>
      )
    }

    return this.props.children
  }
}
```

### API Error Handling

```tsx
// ‚úÖ CORRECT - API error handling with proper types
interface ApiError {
  message: string
  statusCode: number
  code?: string
}

const handleApiError = (error: unknown): ApiError => {
  if (error instanceof Response) {
    return {
      message: `HTTP ${error.status}: ${error.statusText}`,
      statusCode: error.status
    }
  }
  
  if (error instanceof Error) {
    return {
      message: error.message,
      statusCode: 500
    }
  }
  
  return {
    message: 'An unexpected error occurred',
    statusCode: 500
  }
}

// ‚úÖ CORRECT - API call with error handling
const fetchData = async () => {
  try {
    setLoading(true)
    setError(null)
    
    const response = await fetch('/api/data')
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`)
    }
    
    const data = await response.json()
    setData(data)
  } catch (error) {
    const apiError = handleApiError(error)
    setError(apiError.message)
    console.error('API Error:', apiError)
  } finally {
    setLoading(false)
  }
}
```

### Form Validation Errors

```tsx
// ‚úÖ CORRECT - Form error handling
interface FormErrors {
  [key: string]: string
}

const [errors, setErrors] = useState<FormErrors>({})

const validateForm = (): boolean => {
  const newErrors: FormErrors = {}
  
  if (!name.trim()) {
    newErrors.name = 'Name is required'
  }
  
  if (!email.trim()) {
    newErrors.email = 'Email is required'
  } else if (!isValidEmail(email)) {
    newErrors.email = 'Please enter a valid email'
  }
  
  setErrors(newErrors)
  return Object.keys(newErrors).length === 0
}

// ‚úÖ CORRECT - Display form errors
<TextField
  label="Email"
  value={email}
  onChange={setEmail}
  error={errors.email}
  required
/>
```

### User-Friendly Error Messages

```tsx
// ‚úÖ CORRECT - Error message component
interface ErrorMessageProps {
  message: string
  variant?: 'error' | 'warning' | 'info'
  onRetry?: () => void
}

export const ErrorMessage: React.FC<ErrorMessageProps> = ({
  message,
  variant = 'error',
  onRetry
}) => {
  const getVariantClasses = () => {
    switch (variant) {
      case 'error':
        return 'bg-red-50 border-red-200 text-red-800'
      case 'warning':
        return 'bg-yellow-50 border-yellow-200 text-yellow-800'
      case 'info':
        return 'bg-blue-50 border-blue-200 text-blue-800'
      default:
        return 'bg-red-50 border-red-200 text-red-800'
    }
  }

  return (
    <div className={`p-4 border rounded-lg ${getVariantClasses()}`}>
      <div className="flex items-center justify-between">
        <p className="text-sm font-medium">{message}</p>
        {onRetry && (
          <button
            onClick={onRetry}
            className="ml-4 text-sm underline hover:no-underline"
          >
            Try again
          </button>
        )}
      </div>
    </div>
  )
}
```

### Loading and Error States

```tsx
// ‚úÖ CORRECT - Component with loading and error states
const DataComponent = () => {
  const [data, setData] = useState<Data[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  if (loading) {
    return (
      <div className="flex items-center justify-center p-8">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        <span className="ml-2 text-gray-600">Loading...</span>
      </div>
    )
  }

  if (error) {
    return (
      <ErrorMessage
        message={error}
        onRetry={() => fetchData()}
      />
    )
  }

  if (data.length === 0) {
    return (
      <div className="text-center p-8 text-gray-500">
        No data available
      </div>
    )
  }

  return (
    <div>
      {/* Render data */}
    </div>
  )
}
```

### What NOT to Do

‚ùå **Don't ignore errors silently**
‚ùå **Don't show technical error messages to users**
‚ùå **Don't let errors crash the entire app**
‚ùå **Don't use console.error without proper logging**
‚ùå **Don't forget to handle network errors**

### What TO Do

‚úÖ **Always implement error boundaries**
‚úÖ **Show user-friendly error messages**
‚úÖ **Provide retry mechanisms when possible**
‚úÖ **Log errors for debugging**
‚úÖ **Handle different error types appropriately**
‚úÖ **Test error scenarios**

### Error Logging

```tsx
// ‚úÖ CORRECT - Error logging service
const logError = (error: Error, context?: Record<string, unknown>) => {
  // In production, send to error reporting service
  if (process.env.NODE_ENV === 'production') {
    // Send to Sentry, LogRocket, etc.
    console.error('Production Error:', error, context)
  } else {
    // Development logging
    console.error('Development Error:', error, context)
  }
}

// ‚úÖ CORRECT - Using error logging
try {
  // Some operation
} catch (error) {
  logError(error as Error, { 
    component: 'DataComponent',
    action: 'fetchData' 
  })
  setError('Failed to load data')
}
```

**‚ö†Ô∏è FAILURE TO FOLLOW THESE RULES WILL RESULT IN:**
- Poor user experience
- Application crashes
- Difficult debugging
- Code review rejection
description:
globs:
alwaysApply: false
---
